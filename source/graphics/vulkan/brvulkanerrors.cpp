/***************************************

	Vulkan error helpers.

	Copyright (c) 2020-2021 by Rebecca Ann Heineman <becky@burgerbecky.com>

	It is released under an MIT Open Source license. Please see LICENSE for
	license details. Yes, you can use it in a commercial title without paying
	anything, just give me a credit.

	Please? It's not like I'm asking you for money!

***************************************/

#include "brvulkanerrors.h"

#if !defined(DOXYGEN)
#define VALUE_TO_STRING(x, y) \
	case y: \
		pResult = #x; \
		break
#endif

/*! ************************************

	\brief Convert a VkResult enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkResult VkResult as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkResultToString(
	int32_t iVkResult) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkResult) {
		VALUE_TO_STRING(VK_SUCCESS, 0);
		VALUE_TO_STRING(VK_NOT_READY, 1);
		VALUE_TO_STRING(VK_TIMEOUT, 2);
		VALUE_TO_STRING(VK_EVENT_SET, 3);
		VALUE_TO_STRING(VK_EVENT_RESET, 4);
		VALUE_TO_STRING(VK_INCOMPLETE, 5);
		VALUE_TO_STRING(VK_ERROR_OUT_OF_HOST_MEMORY, -1);
		VALUE_TO_STRING(VK_ERROR_OUT_OF_DEVICE_MEMORY, -2);
		VALUE_TO_STRING(VK_ERROR_INITIALIZATION_FAILED, -3);
		VALUE_TO_STRING(VK_ERROR_DEVICE_LOST, -4);
		VALUE_TO_STRING(VK_ERROR_MEMORY_MAP_FAILED, -5);
		VALUE_TO_STRING(VK_ERROR_LAYER_NOT_PRESENT, -6);
		VALUE_TO_STRING(VK_ERROR_EXTENSION_NOT_PRESENT, -7);
		VALUE_TO_STRING(VK_ERROR_FEATURE_NOT_PRESENT, -8);
		VALUE_TO_STRING(VK_ERROR_INCOMPATIBLE_DRIVER, -9);
		VALUE_TO_STRING(VK_ERROR_TOO_MANY_OBJECTS, -10);
		VALUE_TO_STRING(VK_ERROR_FORMAT_NOT_SUPPORTED, -11);
		VALUE_TO_STRING(VK_ERROR_FRAGMENTED_POOL, -12);
		VALUE_TO_STRING(VK_ERROR_UNKNOWN, -13);
		VALUE_TO_STRING(VK_ERROR_OUT_OF_POOL_MEMORY, -1000069000);
		VALUE_TO_STRING(VK_ERROR_INVALID_EXTERNAL_HANDLE, -1000072003);
		VALUE_TO_STRING(VK_ERROR_FRAGMENTATION, -1000161000);
		VALUE_TO_STRING(VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS, -1000257000);
		VALUE_TO_STRING(VK_ERROR_SURFACE_LOST_KHR, -1000000000);
		VALUE_TO_STRING(VK_ERROR_NATIVE_WINDOW_IN_USE_KHR, -1000000001);
		VALUE_TO_STRING(VK_SUBOPTIMAL_KHR, 1000001003);
		VALUE_TO_STRING(VK_ERROR_OUT_OF_DATE_KHR, -1000001004);
		VALUE_TO_STRING(VK_ERROR_INCOMPATIBLE_DISPLAY_KHR, -1000003001);
		VALUE_TO_STRING(VK_ERROR_VALIDATION_FAILED_EXT, -1000011001);
		VALUE_TO_STRING(VK_ERROR_INVALID_SHADER_NV, -1000012000);
		VALUE_TO_STRING(
			VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT, -1000158000);
		VALUE_TO_STRING(VK_ERROR_NOT_PERMITTED_EXT, -1000174001);
		VALUE_TO_STRING(
			VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT, -1000255000);
		VALUE_TO_STRING(VK_THREAD_IDLE_KHR, 1000268000);
		VALUE_TO_STRING(VK_THREAD_DONE_KHR, 1000268001);
		VALUE_TO_STRING(VK_OPERATION_DEFERRED_KHR, 1000268002);
		VALUE_TO_STRING(VK_OPERATION_NOT_DEFERRED_KHR, 1000268003);
		VALUE_TO_STRING(VK_PIPELINE_COMPILE_REQUIRED_EXT, 1000297000);

	default:
		pResult = "VK_ERROR_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkPresentModeKHR enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkPresentModeKHR VkPresentModeKHR as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkPresentModeKHRToString(
	int32_t iVkPresentModeKHR) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkPresentModeKHR) {
		VALUE_TO_STRING(VK_PRESENT_MODE_IMMEDIATE_KHR, 0);
		VALUE_TO_STRING(VK_PRESENT_MODE_MAILBOX_KHR, 1);
		VALUE_TO_STRING(VK_PRESENT_MODE_FIFO_KHR, 2);
		VALUE_TO_STRING(VK_PRESENT_MODE_FIFO_RELAXED_KHR, 3);
		VALUE_TO_STRING(VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR, 1000111000);
		VALUE_TO_STRING(
			VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR, 1000111001);
	default:
		pResult = "VK_PRESENT_MODE_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkColorSpaceKHR enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkColorSpaceKHR VkColorSpaceKHR as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkColorSpaceKHRToString(
	int32_t iVkColorSpaceKHR) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkColorSpaceKHR) {
		VALUE_TO_STRING(VK_COLOR_SPACE_SRGB_NONLINEAR_KHR, 0);
		VALUE_TO_STRING(VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT, 1000104001);
		VALUE_TO_STRING(VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT, 1000104002);
		VALUE_TO_STRING(VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT, 1000104003);
		VALUE_TO_STRING(VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT, 1000104004);
		VALUE_TO_STRING(VK_COLOR_SPACE_BT709_LINEAR_EXT, 1000104005);
		VALUE_TO_STRING(VK_COLOR_SPACE_BT709_NONLINEAR_EXT, 1000104006);
		VALUE_TO_STRING(VK_COLOR_SPACE_BT2020_LINEAR_EXT, 1000104007);
		VALUE_TO_STRING(VK_COLOR_SPACE_HDR10_ST2084_EXT, 1000104008);
		VALUE_TO_STRING(VK_COLOR_SPACE_DOLBYVISION_EXT, 1000104009);
		VALUE_TO_STRING(VK_COLOR_SPACE_HDR10_HLG_EXT, 1000104010);
		VALUE_TO_STRING(VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT, 1000104011);
		VALUE_TO_STRING(VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT, 1000104012);
		VALUE_TO_STRING(VK_COLOR_SPACE_PASS_THROUGH_EXT, 1000104013);
		VALUE_TO_STRING(VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT, 1000104014);
		VALUE_TO_STRING(VK_COLOR_SPACE_DISPLAY_NATIVE_AMD, 1000213000);
	default:
		pResult = "VK_COLOR_SPACE_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkDriverId enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkDriverId VkDriverId as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkDriverIdToString(
	int32_t iVkDriverId) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkDriverId) {
		VALUE_TO_STRING(VK_DRIVER_ID_AMD_PROPRIETARY, 1);
		VALUE_TO_STRING(VK_DRIVER_ID_AMD_OPEN_SOURCE, 2);
		VALUE_TO_STRING(VK_DRIVER_ID_MESA_RADV, 3);
		VALUE_TO_STRING(VK_DRIVER_ID_NVIDIA_PROPRIETARY, 4);
		VALUE_TO_STRING(VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS, 5);
		VALUE_TO_STRING(VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA, 6);
		VALUE_TO_STRING(VK_DRIVER_ID_IMAGINATION_PROPRIETARY, 7);
		VALUE_TO_STRING(VK_DRIVER_ID_QUALCOMM_PROPRIETARY, 8);
		VALUE_TO_STRING(VK_DRIVER_ID_ARM_PROPRIETARY, 9);
		VALUE_TO_STRING(VK_DRIVER_ID_GOOGLE_SWIFTSHADER, 10);
		VALUE_TO_STRING(VK_DRIVER_ID_GGP_PROPRIETARY, 11);
		VALUE_TO_STRING(VK_DRIVER_ID_BROADCOM_PROPRIETARY, 12);
		VALUE_TO_STRING(VK_DRIVER_ID_MESA_LLVMPIPE, 13);
		VALUE_TO_STRING(VK_DRIVER_ID_MOLTENVK, 14);
	default:
		pResult = "VK_DRIVER_ID_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkFormat enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkFormat VkFormat as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkFormatToString(
	int32_t iVkFormat) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkFormat) {
		VALUE_TO_STRING(VK_FORMAT_UNDEFINED, 0);
		VALUE_TO_STRING(VK_FORMAT_R4G4_UNORM_PACK8, 1);
		VALUE_TO_STRING(VK_FORMAT_R4G4B4A4_UNORM_PACK16, 2);
		VALUE_TO_STRING(VK_FORMAT_B4G4R4A4_UNORM_PACK16, 3);
		VALUE_TO_STRING(VK_FORMAT_R5G6B5_UNORM_PACK16, 4);
		VALUE_TO_STRING(VK_FORMAT_B5G6R5_UNORM_PACK16, 5);
		VALUE_TO_STRING(VK_FORMAT_R5G5B5A1_UNORM_PACK16, 6);
		VALUE_TO_STRING(VK_FORMAT_B5G5R5A1_UNORM_PACK16, 7);
		VALUE_TO_STRING(VK_FORMAT_A1R5G5B5_UNORM_PACK16, 8);
		VALUE_TO_STRING(VK_FORMAT_R8_UNORM, 9);
		VALUE_TO_STRING(VK_FORMAT_R8_SNORM, 10);
		VALUE_TO_STRING(VK_FORMAT_R8_USCALED, 11);
		VALUE_TO_STRING(VK_FORMAT_R8_SSCALED, 12);
		VALUE_TO_STRING(VK_FORMAT_R8_UINT, 13);
		VALUE_TO_STRING(VK_FORMAT_R8_SINT, 14);
		VALUE_TO_STRING(VK_FORMAT_R8_SRGB, 15);
		VALUE_TO_STRING(VK_FORMAT_R8G8_UNORM, 16);
		VALUE_TO_STRING(VK_FORMAT_R8G8_SNORM, 17);
		VALUE_TO_STRING(VK_FORMAT_R8G8_USCALED, 18);
		VALUE_TO_STRING(VK_FORMAT_R8G8_SSCALED, 19);
		VALUE_TO_STRING(VK_FORMAT_R8G8_UINT, 20);
		VALUE_TO_STRING(VK_FORMAT_R8G8_SINT, 21);
		VALUE_TO_STRING(VK_FORMAT_R8G8_SRGB, 22);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_UNORM, 23);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_SNORM, 24);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_USCALED, 25);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_SSCALED, 26);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_UINT, 27);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_SINT, 28);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8_SRGB, 29);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_UNORM, 30);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_SNORM, 31);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_USCALED, 32);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_SSCALED, 33);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_UINT, 34);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_SINT, 35);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8_SRGB, 36);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_UNORM, 37);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_SNORM, 38);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_USCALED, 39);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_SSCALED, 40);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_UINT, 41);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_SINT, 42);
		VALUE_TO_STRING(VK_FORMAT_R8G8B8A8_SRGB, 43);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_UNORM, 44);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_SNORM, 45);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_USCALED, 46);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_SSCALED, 47);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_UINT, 48);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_SINT, 49);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8A8_SRGB, 50);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_UNORM_PACK32, 51);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_SNORM_PACK32, 52);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_USCALED_PACK32, 53);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_SSCALED_PACK32, 54);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_UINT_PACK32, 55);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_SINT_PACK32, 56);
		VALUE_TO_STRING(VK_FORMAT_A8B8G8R8_SRGB_PACK32, 57);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_UNORM_PACK32, 58);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_SNORM_PACK32, 59);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_USCALED_PACK32, 60);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_SSCALED_PACK32, 61);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_UINT_PACK32, 62);
		VALUE_TO_STRING(VK_FORMAT_A2R10G10B10_SINT_PACK32, 63);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_UNORM_PACK32, 64);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_SNORM_PACK32, 65);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_USCALED_PACK32, 66);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_SSCALED_PACK32, 67);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_UINT_PACK32, 68);
		VALUE_TO_STRING(VK_FORMAT_A2B10G10R10_SINT_PACK32, 69);
		VALUE_TO_STRING(VK_FORMAT_R16_UNORM, 70);
		VALUE_TO_STRING(VK_FORMAT_R16_SNORM, 71);
		VALUE_TO_STRING(VK_FORMAT_R16_USCALED, 72);
		VALUE_TO_STRING(VK_FORMAT_R16_SSCALED, 73);
		VALUE_TO_STRING(VK_FORMAT_R16_UINT, 74);
		VALUE_TO_STRING(VK_FORMAT_R16_SINT, 75);
		VALUE_TO_STRING(VK_FORMAT_R16_SFLOAT, 76);
		VALUE_TO_STRING(VK_FORMAT_R16G16_UNORM, 77);
		VALUE_TO_STRING(VK_FORMAT_R16G16_SNORM, 78);
		VALUE_TO_STRING(VK_FORMAT_R16G16_USCALED, 79);
		VALUE_TO_STRING(VK_FORMAT_R16G16_SSCALED, 80);
		VALUE_TO_STRING(VK_FORMAT_R16G16_UINT, 81);
		VALUE_TO_STRING(VK_FORMAT_R16G16_SINT, 82);
		VALUE_TO_STRING(VK_FORMAT_R16G16_SFLOAT, 83);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_UNORM, 84);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_SNORM, 85);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_USCALED, 86);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_SSCALED, 87);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_UINT, 88);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_SINT, 89);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16_SFLOAT, 90);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_UNORM, 91);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_SNORM, 92);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_USCALED, 93);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_SSCALED, 94);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_UINT, 95);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_SINT, 96);
		VALUE_TO_STRING(VK_FORMAT_R16G16B16A16_SFLOAT, 97);
		VALUE_TO_STRING(VK_FORMAT_R32_UINT, 98);
		VALUE_TO_STRING(VK_FORMAT_R32_SINT, 99);
		VALUE_TO_STRING(VK_FORMAT_R32_SFLOAT, 100);
		VALUE_TO_STRING(VK_FORMAT_R32G32_UINT, 101);
		VALUE_TO_STRING(VK_FORMAT_R32G32_SINT, 102);
		VALUE_TO_STRING(VK_FORMAT_R32G32_SFLOAT, 103);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32_UINT, 104);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32_SINT, 105);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32_SFLOAT, 106);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32A32_UINT, 107);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32A32_SINT, 108);
		VALUE_TO_STRING(VK_FORMAT_R32G32B32A32_SFLOAT, 109);
		VALUE_TO_STRING(VK_FORMAT_R64_UINT, 110);
		VALUE_TO_STRING(VK_FORMAT_R64_SINT, 111);
		VALUE_TO_STRING(VK_FORMAT_R64_SFLOAT, 112);
		VALUE_TO_STRING(VK_FORMAT_R64G64_UINT, 113);
		VALUE_TO_STRING(VK_FORMAT_R64G64_SINT, 114);
		VALUE_TO_STRING(VK_FORMAT_R64G64_SFLOAT, 115);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64_UINT, 116);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64_SINT, 117);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64_SFLOAT, 118);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64A64_UINT, 119);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64A64_SINT, 120);
		VALUE_TO_STRING(VK_FORMAT_R64G64B64A64_SFLOAT, 121);
		VALUE_TO_STRING(VK_FORMAT_B10G11R11_UFLOAT_PACK32, 122);
		VALUE_TO_STRING(VK_FORMAT_E5B9G9R9_UFLOAT_PACK32, 123);
		VALUE_TO_STRING(VK_FORMAT_D16_UNORM, 124);
		VALUE_TO_STRING(VK_FORMAT_X8_D24_UNORM_PACK32, 125);
		VALUE_TO_STRING(VK_FORMAT_D32_SFLOAT, 126);
		VALUE_TO_STRING(VK_FORMAT_S8_UINT, 127);
		VALUE_TO_STRING(VK_FORMAT_D16_UNORM_S8_UINT, 128);
		VALUE_TO_STRING(VK_FORMAT_D24_UNORM_S8_UINT, 129);
		VALUE_TO_STRING(VK_FORMAT_D32_SFLOAT_S8_UINT, 130);
		VALUE_TO_STRING(VK_FORMAT_BC1_RGB_UNORM_BLOCK, 131);
		VALUE_TO_STRING(VK_FORMAT_BC1_RGB_SRGB_BLOCK, 132);
		VALUE_TO_STRING(VK_FORMAT_BC1_RGBA_UNORM_BLOCK, 133);
		VALUE_TO_STRING(VK_FORMAT_BC1_RGBA_SRGB_BLOCK, 134);
		VALUE_TO_STRING(VK_FORMAT_BC2_UNORM_BLOCK, 135);
		VALUE_TO_STRING(VK_FORMAT_BC2_SRGB_BLOCK, 136);
		VALUE_TO_STRING(VK_FORMAT_BC3_UNORM_BLOCK, 137);
		VALUE_TO_STRING(VK_FORMAT_BC3_SRGB_BLOCK, 138);
		VALUE_TO_STRING(VK_FORMAT_BC4_UNORM_BLOCK, 139);
		VALUE_TO_STRING(VK_FORMAT_BC4_SNORM_BLOCK, 140);
		VALUE_TO_STRING(VK_FORMAT_BC5_UNORM_BLOCK, 141);
		VALUE_TO_STRING(VK_FORMAT_BC5_SNORM_BLOCK, 142);
		VALUE_TO_STRING(VK_FORMAT_BC6H_UFLOAT_BLOCK, 143);
		VALUE_TO_STRING(VK_FORMAT_BC6H_SFLOAT_BLOCK, 144);
		VALUE_TO_STRING(VK_FORMAT_BC7_UNORM_BLOCK, 145);
		VALUE_TO_STRING(VK_FORMAT_BC7_SRGB_BLOCK, 146);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK, 147);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK, 148);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK, 149);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK, 150);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK, 151);
		VALUE_TO_STRING(VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK, 152);
		VALUE_TO_STRING(VK_FORMAT_EAC_R11_UNORM_BLOCK, 153);
		VALUE_TO_STRING(VK_FORMAT_EAC_R11_SNORM_BLOCK, 154);
		VALUE_TO_STRING(VK_FORMAT_EAC_R11G11_UNORM_BLOCK, 155);
		VALUE_TO_STRING(VK_FORMAT_EAC_R11G11_SNORM_BLOCK, 156);
		VALUE_TO_STRING(VK_FORMAT_ASTC_4x4_UNORM_BLOCK, 157);
		VALUE_TO_STRING(VK_FORMAT_ASTC_4x4_SRGB_BLOCK, 158);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x4_UNORM_BLOCK, 159);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x4_SRGB_BLOCK, 160);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x5_UNORM_BLOCK, 161);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x5_SRGB_BLOCK, 162);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x5_UNORM_BLOCK, 163);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x5_SRGB_BLOCK, 164);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x6_UNORM_BLOCK, 165);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x6_SRGB_BLOCK, 166);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x5_UNORM_BLOCK, 167);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x5_SRGB_BLOCK, 168);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x6_UNORM_BLOCK, 169);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x6_SRGB_BLOCK, 170);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x8_UNORM_BLOCK, 171);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x8_SRGB_BLOCK, 172);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x5_UNORM_BLOCK, 173);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x5_SRGB_BLOCK, 174);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x6_UNORM_BLOCK, 175);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x6_SRGB_BLOCK, 176);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x8_UNORM_BLOCK, 177);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x8_SRGB_BLOCK, 178);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x10_UNORM_BLOCK, 179);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x10_SRGB_BLOCK, 180);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x10_UNORM_BLOCK, 181);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x10_SRGB_BLOCK, 182);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x12_UNORM_BLOCK, 183);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x12_SRGB_BLOCK, 184);
		VALUE_TO_STRING(VK_FORMAT_G8B8G8R8_422_UNORM, 1000156000);
		VALUE_TO_STRING(VK_FORMAT_B8G8R8G8_422_UNORM, 1000156001);
		VALUE_TO_STRING(VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM, 1000156002);
		VALUE_TO_STRING(VK_FORMAT_G8_B8R8_2PLANE_420_UNORM, 1000156003);
		VALUE_TO_STRING(VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM, 1000156004);
		VALUE_TO_STRING(VK_FORMAT_G8_B8R8_2PLANE_422_UNORM, 1000156005);
		VALUE_TO_STRING(VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM, 1000156006);
		VALUE_TO_STRING(VK_FORMAT_R10X6_UNORM_PACK16, 1000156007);
		VALUE_TO_STRING(VK_FORMAT_R10X6G10X6_UNORM_2PACK16, 1000156008);
		VALUE_TO_STRING(
			VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16, 1000156009);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16, 1000156010);
		VALUE_TO_STRING(
			VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16, 1000156011);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16, 1000156012);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16, 1000156013);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16, 1000156014);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16, 1000156015);
		VALUE_TO_STRING(
			VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16, 1000156016);
		VALUE_TO_STRING(VK_FORMAT_R12X4_UNORM_PACK16, 1000156017);
		VALUE_TO_STRING(VK_FORMAT_R12X4G12X4_UNORM_2PACK16, 1000156018);
		VALUE_TO_STRING(
			VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16, 1000156019);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16, 1000156020);
		VALUE_TO_STRING(
			VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16, 1000156021);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16, 1000156022);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16, 1000156023);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16, 1000156024);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16, 1000156025);
		VALUE_TO_STRING(
			VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16, 1000156026);
		VALUE_TO_STRING(VK_FORMAT_G16B16G16R16_422_UNORM, 1000156027);
		VALUE_TO_STRING(VK_FORMAT_B16G16R16G16_422_UNORM, 1000156028);
		VALUE_TO_STRING(VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM, 1000156029);
		VALUE_TO_STRING(VK_FORMAT_G16_B16R16_2PLANE_420_UNORM, 1000156030);
		VALUE_TO_STRING(VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM, 1000156031);
		VALUE_TO_STRING(VK_FORMAT_G16_B16R16_2PLANE_422_UNORM, 1000156032);
		VALUE_TO_STRING(VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM, 1000156033);
		VALUE_TO_STRING(VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG, 1000054000);
		VALUE_TO_STRING(VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG, 1000054001);
		VALUE_TO_STRING(VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG, 1000054002);
		VALUE_TO_STRING(VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG, 1000054003);
		VALUE_TO_STRING(VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG, 1000054004);
		VALUE_TO_STRING(VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG, 1000054005);
		VALUE_TO_STRING(VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG, 1000054006);
		VALUE_TO_STRING(VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG, 1000054007);
		VALUE_TO_STRING(VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK_EXT, 1000066000);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK_EXT, 1000066001);
		VALUE_TO_STRING(VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK_EXT, 1000066002);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK_EXT, 1000066003);
		VALUE_TO_STRING(VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK_EXT, 1000066004);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK_EXT, 1000066005);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK_EXT, 1000066006);
		VALUE_TO_STRING(VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK_EXT, 1000066007);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK_EXT, 1000066008);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK_EXT, 1000066009);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK_EXT, 1000066010);
		VALUE_TO_STRING(VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK_EXT, 1000066011);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK_EXT, 1000066012);
		VALUE_TO_STRING(VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK_EXT, 1000066013);
		VALUE_TO_STRING(VK_FORMAT_A4R4G4B4_UNORM_PACK16_EXT, 1000340000);
		VALUE_TO_STRING(VK_FORMAT_A4B4G4R4_UNORM_PACK16_EXT, 1000340001);
	default:
		pResult = "VK_FORMAT_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkImageTiling enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkImageTiling VkImageTiling as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkImageTilingToString(
	int32_t iVkImageTiling) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkImageTiling) {
		VALUE_TO_STRING(VK_IMAGE_TILING_OPTIMAL, 0);
		VALUE_TO_STRING(VK_IMAGE_TILING_LINEAR, 1);
		VALUE_TO_STRING(VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT, 1000158000);
	default:
		pResult = "VK_IMAGE_TILING_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkPointClippingBehavior enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkPointClippingBehavior VkPointClippingBehavior as an int32_t.
	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkPointClippingBehaviorToString(
	int32_t iVkPointClippingBehavior) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkPointClippingBehavior) {
		VALUE_TO_STRING(VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES, 0);
		VALUE_TO_STRING(VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY, 1);
	default:
		pResult = "VK_POINT_CLIPPING_BEHAVIOR_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkShaderFloatControlsIndependence enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkShaderFloatControlsIndependence VkShaderFloatControlsIndependence
		as an int32_t.

	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API
Burger::Vulkan::VkShaderFloatControlsIndependenceToString(
	int32_t iVkShaderFloatControlsIndependence) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkShaderFloatControlsIndependence) {
		VALUE_TO_STRING(VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY, 0);
		VALUE_TO_STRING(VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL, 1);
		VALUE_TO_STRING(VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE, 2);
	default:
		pResult = "VK_SHADER_FLOAT_CONTROLS_UNKNOWN";
		break;
	}
	return pResult;
}

/*! ************************************

	\brief Convert a VkPhysicalDeviceType enum into a valid string

	Look up the value of the result code and return the corresponding result
	string.

	\param iVkPhysicalDeviceType VkPhysicalDeviceType as an int32_t.

	\return Immutable "C" string pointer to the error name.

***************************************/

const char* BURGER_API Burger::Vulkan::VkPhysicalDeviceTypeToString(
	int32_t iVkPhysicalDeviceType) BURGER_NOEXCEPT
{
	const char* pResult;

	// Note: The numbers are found in vulkan_core.h from the Vulkan headers.
	switch (iVkPhysicalDeviceType) {
		VALUE_TO_STRING(VK_PHYSICAL_DEVICE_TYPE_OTHER, 0);
		VALUE_TO_STRING(VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU, 1);
		VALUE_TO_STRING(VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU, 2);
		VALUE_TO_STRING(VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU, 3);
		VALUE_TO_STRING(VK_PHYSICAL_DEVICE_TYPE_CPU, 4);
	default:
		pResult = "VK_PHYSICAL_DEVICE_TYPE_UNKNOWN";
		break;
	}
	return pResult;
}
