/***************************************

	Assembly for MacOSX Darwin

	Copyright 1995-2023 by Rebecca Ann Heineman becky@burgerbecky.com

	Build with XCode tool chain

	XCode uses a C++ parser and will try to assemble this file on all
	CPU types, so test for the proper CPU type before invoking any cpu
	instructions.

	double BURGER_API Burger::ModuloRadians(double dInput) BURGER_NOEXCEPT

***************************************/

/***************************************

	PowerPC 32/64 version
	
	r0, r3-12, fp0-fp13 are volatile
	Result in fp1
	fInput = fp1

***************************************/

#if defined(__ppc__) || defined(__ppc64__)
	.align 2
	.text

	.globl __ZN6Burger13ModuloRadiansEd
__ZN6Burger13ModuloRadiansEd:

/* Fetch the pointers */
	lis		r3, ha16(__ZN6Burger16g_dReciprocalPi2E)

/* Create 0x4330000080000000 for integer to float conversions */
	lis		r6, 0x4330
	lis		r4, ha16(__ZN6Burger7g_dHalfE)
	lis		r7, 0x8000
	lis		r5, ha16(__ZN6Burger9g_dNegPi2E)

/* Load in 1/ 2Pi */
	lfd		f3, lo16(__ZN6Burger16g_dReciprocalPi2E)(r3)

/* Load in 0.5f */
	lfd		f4, lo16(__ZN6Burger7g_dHalfE)(r4)

/* (fInput*g_fReciprocalPi2) */
	fmul	f3, f1, f3

/* Load in Pi2 */
	lfd		f5, lo16(__ZN6Burger9g_dNegPi2E)(r5)

/* (fInput*g_fReciprocalPi2)+g_fHalf */
	fadd	f3, f3, f4

/* fmadd doesn't handle sign properly so it failed the unit test */
/* Used explicit fmul and fadd to get the accuracy */
/* (fInput*g_fReciprocalPi2)+g_fHalf */
/*	fmadd	f3, f1, f3, f4 */

/* Store 0x4330000080000000 */
	stw		r6, -16(r1)
	stw		r7, -12(r1)

/* Load 0x4330000080000000 in FPU */
	lfd		f2, -16(r1)

/* Convert to integer */
	fctiwz	f0, f3

/* Store the integer in memory (64 bit) */
	stfd	f0, -8(r1)

/* Extract the low word */
	lwz		r0, -4(r1)

/* Flip the bit */
	xor		r0,r0,r7

/* Create a fake double */
	stw		r6,-8(r1)

/* Store the integer */
	stw		r0,-4(r1)

/* Load the rounded double */
	lfd		f0,-8(r1)

/* Complete the int to float conversion */
	fsub 	f2,f0,f2

/* Compare the two and get rid of the pre-rounded */
	fcmpu 	cr0,f2,f3
	ble		1f

/* Load 1.0f */
	fadd	f0, f4, f4

/* Fixup */
	fsub	f2, f2, f0

/* Don't use fnmsubs, it doesn't handle the sign bit properly */
/* (fVar*-g_fPi2) + fInput */
1:	fmadd	f1, f2, f5, f1
	blr

#endif

/***************************************

	Intel 32 bit version

	eax, ecx and edx are volatile
	Result in 8087 FPU
	fInput = 4(%esp)

***************************************/

#if defined(__i386__)
	.align	4,0x90
	.globl __ZN6Burger13ModuloRadiansEd
__ZN6Burger13ModuloRadiansEd:

/* Load into the FPU */
	movsd		4(%esp), %xmm0

/* Load in 1/ 2Pi */
	movsd		(__ZN6Burger16g_dReciprocalPi2E), %xmm2

/* Multiply (Really fInput/2Pi) */
	mulsd		%xmm0, %xmm2

/* Add half for rounding */
	addsd		(__ZN6Burger7g_dHalfE), %xmm2

/* Convert to integer */
	cvttsd2si	%xmm2, %eax
	cvtsi2sdl	%eax, %xmm1

/* Compare the two and get rid of the pre-rounded */
	ucomisd		%xmm2, %xmm1

/* Did it round up? */
	jbe			1f

/* Fixup */
	subsd		(__ZN6Burger6g_dOneE), %xmm1

/* Mul by 2 pi */
1:	mulsd		(__ZN6Burger6g_dPi2E), %xmm1

/* Subtract and clean up */
	subsd		%xmm1, %xmm0

/* Return in st(0) */
	movsd		%xmm0, 4(%esp)
	fldl		4(%esp)
	ret

#endif
