/***************************************

	DJB2 hash manager (Dan Bernstein's algorithm)

	Implemented following the documentation found in
	http::/www.cs.yorku.ca/~oz/hash.html

	Copyright (c) 1995-2017 by Rebecca Ann Heineman <becky@burgerbecky.com>

	It is released under an MIT Open Source license. Please see LICENSE
	for license details. Yes, you can use it in a
	commercial title without paying anything, just give me a credit.
	Please? It's not like I'm asking you for money!
	
***************************************/

#include "brdjb2hash.h"
#include "brstringfunctions.h"

/*! ************************************

	\brief Hash data using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 + str[i];
	
	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.
	\return 32 bit hash value generated by the data.
	\sa DJB2HashAddCase(const void *,WordPtr,Word32) or DJB2HashXor(const void *,WordPtr,Word32)

***************************************/

WordPtr BURGER_API Burger::DJB2HashAdd(const void* pInput,WordPtr uInputCount,Word32 uHashSeed)
{
	if (uInputCount) {
		do {
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) + static_cast<const Word8 *>(pInput)[0];
			pInput = static_cast<const Word8 *>(pInput)+1;
		} while (--uInputCount);
	}
	return uHashSeed;
}

/*! ************************************

	\brief Hash string data using forced lower case using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 + ToLower(str[i]);
	
	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\note This function converts all upper case characters into lower case
		to yield a case insensitive hash

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.
	\return 32 bit hash value generated by the data.
	\sa DJB2HashAdd(const void *,WordPtr,Word32) or DJB2HashXorCase(const void *,WordPtr,Word32)

***************************************/

WordPtr BURGER_API Burger::DJB2HashAddCase(const void *pInput,WordPtr uInputCount,Word32 uHashSeed)
{
	if (uInputCount) {
		do {
			// Seed*33 ^ pInput[0]
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) + ToLower(static_cast<const Word8 *>(pInput)[0]);
			pInput = static_cast<const Word8 *>(pInput)+1;
		} while (--uInputCount);
	}
	return uHashSeed;
}


/*! ************************************

	\brief Hash data using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 ^ str[i];
	
	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.
	\return 32 bit hash value generated by the data.
	\sa DJB2HashXorCase(const void *,WordPtr,Word32) or DJB2HashAdd(const void *,WordPtr,Word32)

***************************************/

WordPtr BURGER_API Burger::DJB2HashXor(const void* pInput,WordPtr uInputCount,Word32 uHashSeed)
{
	if (uInputCount) {
		do {
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) ^ static_cast<const Word8 *>(pInput)[0];
			pInput = static_cast<const Word8 *>(pInput)+1;
		} while (--uInputCount);
	}
	return uHashSeed;
}

/*! ************************************

	\brief Hash string data using forced lower case using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 ^ ToLower(str[i]);
	
	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\note This function converts all upper case characters into lower case
		to yield a case insensitive hash

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.
	\return 32 bit hash value generated by the data.
	\sa DJB2HashXor(const void *,WordPtr,Word32) or DJB2HashAddCase(const void *,WordPtr,Word32)

***************************************/

WordPtr BURGER_API Burger::DJB2HashXorCase(const void *pInput,WordPtr uInputCount,Word32 uHashSeed)
{
	if (uInputCount) {
		do {
			// Seed*33 ^ pInput[0]
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) ^ ToLower(static_cast<const Word8 *>(pInput)[0]);
			pInput = static_cast<const Word8 *>(pInput)+1;
		} while (--uInputCount);
	}
	return uHashSeed;
}