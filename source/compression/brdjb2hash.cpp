/***************************************

	DJB2 hash manager (Dan Bernstein's algorithm)

	Implemented following the documentation found in
	http::/www.cs.yorku.ca/~oz/hash.html

	Copyright (c) 1995-2023 by Rebecca Ann Heineman <becky@burgerbecky.com>

	It is released under an MIT Open Source license. Please see LICENSE for
	license details. Yes, you can use it in a commercial title without paying
	anything, just give me a credit.

	Please? It's not like I'm asking you for money!

***************************************/

#include "brdjb2hash.h"
#include "brstringfunctions.h"

/*! ************************************

	\brief Hash data using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 + str[i];

	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.

	\return 32 bit hash value generated by the data.

	\sa DJB2_hash_add_case(const void *,uintptr_t,uint32_t),
		or DJB2_hash_xor(const void *,uintptr_t,uint32_t)

***************************************/

uintptr_t BURGER_API Burger::DJB2_hash_add(const void* pInput,
	uintptr_t uInputCount, uint32_t uHashSeed) BURGER_NOEXCEPT
{
	if (uInputCount) {
		do {
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) +
				static_cast<const uint8_t*>(pInput)[0];

			pInput = static_cast<const uint8_t*>(pInput) + 1;
		} while (--uInputCount);
	}
	return uHashSeed;
}

/*! ************************************

	\brief Hash string data using forced lower case using the djb2 (Daniel
		Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 + ToLower(str[i]);

	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\note This function converts all upper case characters into lower case
		to yield a case insensitive hash

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.

	\return 32 bit hash value generated by the data.

	\sa DJB2_hash_add(const void *,uintptr_t,uint32_t),
		or DJB2_hash_xor_case(const void *,uintptr_t,uint32_t)

***************************************/

uintptr_t BURGER_API Burger::DJB2_hash_add_case(const void* pInput,
	uintptr_t uInputCount, uint32_t uHashSeed) BURGER_NOEXCEPT
{
	if (uInputCount) {
		do {
			// Seed*33 ^ pInput[0]
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) +
				ToLower(static_cast<const uint8_t*>(pInput)[0]);

			pInput = static_cast<const uint8_t*>(pInput) + 1;
		} while (--uInputCount);
	}
	return uHashSeed;
}

/*! ************************************

	\brief Hash data using the djb2 (Daniel Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 ^ str[i];

	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.

	\return 32 bit hash value generated by the data.

	\sa DJB2_hash_xor_case(const void *,uintptr_t,uint32_t),
		or DJB2_hash_add(const void *,uintptr_t,uint32_t)

***************************************/

uintptr_t BURGER_API Burger::DJB2_hash_xor(const void* pInput,
	uintptr_t uInputCount, uint32_t uHashSeed) BURGER_NOEXCEPT
{
	if (uInputCount) {
		do {
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) ^
				static_cast<const uint8_t*>(pInput)[0];

			pInput = static_cast<const uint8_t*>(pInput) + 1;
		} while (--uInputCount);
	}
	return uHashSeed;
}

/*! ************************************

	\brief Hash string data using forced lower case using the djb2 (Daniel
		Julius Bernstein) algorithm

	This algorithm (k=33) was first reported by Dan Bernstein many years
	ago in comp.lang.c. This uses hash(i) = hash(i - 1) * 33 ^ ToLower(str[i]);

	The magic of number 33 (why it works better than many other constants,
	prime or not) has never been adequately explained.

	Further reading: http://www.cs.yorku.ca/~oz/hash.html#djb2

	\note This function converts all upper case characters into lower case
		to yield a case insensitive hash

	\param pInput Pointer to the data to hash
	\param uInputCount Number of bytes of data to hash
	\param uHashSeed Value to seed the hash with.

	\return 32 bit hash value generated by the data.

	\sa DJB2_hash_xor(const void *,uintptr_t,uint32_t),
		or DJB2_hash_add_case(const void *,uintptr_t,uint32_t)

***************************************/

uintptr_t BURGER_API Burger::DJB2_hash_xor_case(const void* pInput,
	uintptr_t uInputCount, uint32_t uHashSeed) BURGER_NOEXCEPT
{
	if (uInputCount) {
		do {
			// Seed*33 ^ pInput[0]
			uHashSeed = ((uHashSeed << 5U) + uHashSeed) ^
				ToLower(static_cast<const uint8_t*>(pInput)[0]);

			pInput = static_cast<const uint8_t*>(pInput) + 1;
		} while (--uInputCount);
	}
	return uHashSeed;
}
